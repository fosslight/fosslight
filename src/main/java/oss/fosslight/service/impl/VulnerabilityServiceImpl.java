/*
 * Copyright (c) 2021 LG Electronics Inc.
 * SPDX-License-Identifier: AGPL-3.0-only 
 */

package oss.fosslight.service.impl;

import java.math.BigDecimal;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.apache.commons.collections.MapUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lombok.extern.slf4j.Slf4j;
import oss.fosslight.CoTopComponent;
import oss.fosslight.common.CoCodeManager;
import oss.fosslight.common.CoConstDef;
import oss.fosslight.common.CommonFunction;
import oss.fosslight.domain.CoMail;
import oss.fosslight.domain.CoMailManager;
import oss.fosslight.domain.CommentsHistory;
import oss.fosslight.domain.OssMaster;
import oss.fosslight.domain.T2CodeDtl;
import oss.fosslight.domain.Vulnerability;
import oss.fosslight.repository.CodeMapper;
import oss.fosslight.repository.OssMapper;
import oss.fosslight.repository.VulnerabilityMapper;
import oss.fosslight.service.CommentService;
import oss.fosslight.service.OssService;
import oss.fosslight.service.VulnerabilityService;

@Service
@Slf4j
public class VulnerabilityServiceImpl extends CoTopComponent implements VulnerabilityService {
	private static final Logger scheduler_log = LoggerFactory.getLogger("SCHEDULER_LOG");

	@Autowired Environment env;
	@Autowired VulnerabilityMapper vulnerabilityMapper;
	@Autowired OssService ossService;
	@Autowired OssMapper ossMapper;
	@Autowired CodeMapper codeMapper;
	@Autowired CommentService commentService;
	
	@Override
	public HashMap<String, Object> getVulnerabilityList(Vulnerability vulnerability, boolean exportFlag) {
		HashMap<String, Object> map = new HashMap<String, Object>();
		
		// Table alias 지정이 필요한 칼럼
		Map<String, String> ambiguousMap = new HashMap<>();
		ambiguousMap.put("CVE_ID", "T1");
		String filterCondition = CommonFunction.getFilterToString(vulnerability.getFilters(), ambiguousMap);
		if (!isEmpty(filterCondition)) {
			vulnerability.setFilterCondition(filterCondition);
		}
		
		if (isEmpty(vulnerability.getOssNameAllSearchFlag())) {
			vulnerability.setOssNameAllSearchFlag(CoConstDef.FLAG_NO);
		}
		
		if (CoConstDef.FLAG_YES.equals(vulnerability.getOssNameAllSearchFlag()) && "PRODUCT".equals(vulnerability.getSidx().toUpperCase())) {
			vulnerability.setSidx("version");
			vulnerability.setSord("desc");
		}
		
		List<String> searchProductParam = new ArrayList<>();
		if (vulnerability.getProduct() != null) {
			if (vulnerability.getProduct().contains(" ")) {
				searchProductParam.add(vulnerability.getProduct().replaceAll(" ", "_"));
			} else {
				searchProductParam.add(vulnerability.getProduct());
			}
		}
		
		String[] nicknameList = ossService.getOssNickNameListByOssName(vulnerability.getProduct());
		if (nicknameList != null && nicknameList.length > 0) {
			List<String> ossNicknameList = new ArrayList<>(Arrays.asList(nicknameList));
			ossNicknameList.add(vulnerability.getProduct().replaceAll(" ", "_"));
			for (String nickname : nicknameList) {
				searchProductParam.add(nickname.replaceAll(" ", "_"));
			}
		}
		
		if (searchProductParam != null && !searchProductParam.isEmpty()) {
			vulnerability.setOssNicknames(searchProductParam.toArray(new String [searchProductParam.size()]));
			
			String searchProduct = "\"";
			int idx = 0;
			for (String searchParam : searchProductParam) {
				searchProduct += searchParam.replaceAll(" ", "_");
				if (idx != searchProductParam.size()-1) {
					searchProduct += "\" \"";
				}
				idx++;
			}
			searchProduct += "\"";
			vulnerability.setSearchProduct(searchProduct);
		}
		
		int records = vulnerabilityMapper.selectVulnerabilityTotalCount(vulnerability);
		vulnerability.setTotListSize(records);
		
		List<Vulnerability> list = null;
		if (exportFlag) {
			list = vulnerabilityMapper.selectVulnerabilityExportList(vulnerability);
		} else {
			list = vulnerabilityMapper.selectVulnerabilityList(vulnerability);
		}
		
		List<String> replaceVendor = new ArrayList<>();
		List<String> replaceNickname = new ArrayList<>();
		
		for (Vulnerability vuln : list) {
			String vendor = vuln.getVendor();
			for (String vendorNm : vendor.split(",")) {
				if (!isEmpty(vendorNm)) {
					replaceVendor.add(vendorNm);
				}
			}
			vendor = "";
			if (replaceVendor.size() > 0) {
				replaceVendor = replaceVendor.stream().distinct().collect(Collectors.toList());
				
				for (String reNm : replaceVendor) {
					vendor += reNm + ",";
				}
				vuln.setVendor(vendor.substring(0, vendor.length()-1));
			} else {
				vuln.setVendor("");
			}
			replaceVendor.clear();
			
			if (vuln.getOssNickname() != null) {
				String nickname = vuln.getOssNickname();
				for (String nick : nickname.split(",")) {
					if (!isEmpty(nick)) {
						replaceNickname.add(nick);
					}
				}
				
				nickname = "";
				if (replaceNickname.size() > 0) {
					Collections.sort(replaceNickname);
					
					for (String reNm : replaceNickname) {
						nickname += reNm + ",";
					}
					vuln.setOssNickname(nickname.substring(0, nickname.length()-1));
				} else {
					vuln.setOssNickname("");
				}
				replaceNickname.clear();
			}
		}
		
		map.put("page", vulnerability.getCurPage());
		map.put("total", vulnerability.getTotBlockSize());
		map.put("records", records);
		map.put("rows", list);
		
		return map;
	}
	
	@Override
	@Cacheable(value="autocompleteVulnerabilityCache", key="{#root.methodName}")
	public HashMap<String, Object> getVulnerabilityAutoComplete() {
		
		HashMap<String, Object> map = new HashMap<String, Object>();
		
		List<String> nameList = vulnerabilityMapper.selectVulnerabilityOSSNameAutoComplete();
		List<String> cveIdList = vulnerabilityMapper.selectVulnerabilityCveIdAutoComplete();
		
		map.put("nameList", nameList);
		map.put("cveIdList", cveIdList);

		return map;
	}

	@Override
	public List<String> getVulnerabilityVersionAutoComplete(String name) {

		List<String> versionList = vulnerabilityMapper.selectVulnerabilityOSSVersionAutoComplete(name);
		
		return versionList;
	}
	
	@Override
	public Map<String, Object> getVulnListByOssName(OssMaster bean) {
		Map<String, Object> result = new HashMap<String, Object>();
		boolean underscoreFlag = false;
		
		if ("N/A".equals(bean.getOssVersion())) {
			bean.setOssVersion("");
		}
		
		String ossName = bean.getOssName();
		String ossVersion = bean.getOssVersion().equals("-") ? "" : bean.getOssVersion();
		String key = (bean.getOssName() + "_" + ossVersion).toUpperCase();
		String refOssName = "";
		
		List<String> includeCpeEnvironmentList = new ArrayList<>();
		List<String> excludeCpeEnvironmentList = new ArrayList<>();
		List<String> includeCpeList = null;
		List<String> excludeCpeList = null;
		List<String> ossVersionAliasWithColon = new ArrayList<>();
		List<String> ossVersionAliasWithoutColon = new ArrayList<>();
		boolean includeCpeCheckFlag = false;
		
		if (CoCodeManager.OSS_INFO_UPPER.containsKey(key)) {
			OssMaster ossInfo = CoCodeManager.OSS_INFO_UPPER.get(key);
			if (!ossInfo.getOssName().equals(ossInfo.getOssNameTemp())) {
				refOssName = ossInfo.getOssNameTemp();
			}
			
			if (ossInfo.getIncludeCpe() != null) {
				includeCpeCheckFlag = true; 
				includeCpeList = new ArrayList<>(Arrays.asList(ossInfo.getIncludeCpe().split(",")));
			}
			if (ossInfo.getExcludeCpe() != null) {
				excludeCpeList = new ArrayList<>(Arrays.asList(ossInfo.getExcludeCpe().split(",")));
			}
			if (ossInfo.getOssVersionAlias() != null) {
				for (String alias : ossInfo.getOssVersionAlias().split(",")) {
					if (alias.contains(":")) {
						ossVersionAliasWithColon.add(alias);
					} else {
						ossVersionAliasWithoutColon.add(alias);
					}
				}
				bean.setOssVersionAliasWithColon(ossVersionAliasWithColon.toArray(new String[ossVersionAliasWithColon.size()]));
			}
			
			ossVersionAliasWithoutColon.add(isEmpty(bean.getOssVersion()) ? "-" : bean.getOssVersion());
			bean.setOssVersionAliases(ossVersionAliasWithoutColon.toArray(new String[ossVersionAliasWithoutColon.size()]));
		} else {
			if (ossName.contains("_")) {
				underscoreFlag = true;
				String chkKey = (bean.getOssName().replaceAll("_", " ") + "_" + avoidNull(bean.getOssVersion())).toUpperCase();
				if (CoCodeManager.OSS_INFO_UPPER.containsKey(chkKey)) {
					OssMaster ossInfo = CoCodeManager.OSS_INFO_UPPER.get(chkKey);
					if (!ossInfo.getOssName().equals(ossInfo.getOssNameTemp())) {
						refOssName = ossInfo.getOssNameTemp();
					} else {
						ossName = bean.getOssName().replaceAll("_", " ");
					}
				}
			}
		}
		
		boolean checkVulnDataFlag = false;
		List<Vulnerability> list = new ArrayList<>();
		
		if (includeCpeCheckFlag) {
			List<Map<String, Object>> includeVendorProductInfoList = null;
			List<Map<String, Object>> excludeVendorProductInfoList = null;
			
			if (includeCpeList != null && !includeCpeList.isEmpty()) {
				generateIncludeCpeParam(bean, includeCpeList, includeCpeEnvironmentList);
				includeVendorProductInfoList = vulnerabilityMapper.selectVendorProductByCpeInfo(bean);
			}
			
			if (excludeCpeList != null && !excludeCpeList.isEmpty()) {
				generateExcludeCpeParam(bean, excludeCpeList, excludeCpeEnvironmentList);
				excludeVendorProductInfoList = vulnerabilityMapper.selectVendorProductByCpeInfo(bean);
			}

			List<Map<String, Object>> filteredVendorProductInfoList = new ArrayList<>();
			
			if (includeVendorProductInfoList != null && !includeVendorProductInfoList.isEmpty()) {
				if (excludeVendorProductInfoList != null && !excludeVendorProductInfoList.isEmpty()) {
					generateIncludeCpeMatchList(includeVendorProductInfoList, excludeVendorProductInfoList, includeCpeEnvironmentList, filteredVendorProductInfoList, null);
				} else {
					generateIncludeCpeMatchList(includeVendorProductInfoList, null, includeCpeEnvironmentList, filteredVendorProductInfoList, null);
				}
			}
			
			Map<String, Object> maxScoreVulnMap = null;
			if (filteredVendorProductInfoList != null && !filteredVendorProductInfoList.isEmpty()) {
				Collections.sort(filteredVendorProductInfoList, new Comparator<Map<String, Object>>() {
					@Override
					public int compare(Map<String, Object> o1, Map<String, Object> o2) {
						if (new BigDecimal(o1.get("CVSS_SCORE").toString()).compareTo(new BigDecimal(o2.get("CVSS_SCORE").toString())) > 0) {
							return -1;
						}else {
							return 1;
						}
					}
				});
				
				maxScoreVulnMap = filteredVendorProductInfoList.get(0);
			}
			
			if (maxScoreVulnMap != null && !maxScoreVulnMap.isEmpty()) {
				checkVulnDataFlag = true;
				
				Vulnerability vuln = new Vulnerability();
				vuln.setProduct(bean.getOssName());
				vuln.setVersion(bean.getOssVersion());
				vuln.setCveId((String) maxScoreVulnMap.get("CVE_ID"));
				vuln.setCvssScore(String.valueOf((Float) maxScoreVulnMap.get("CVSS_SCORE")));
				vuln.setVulnSummary((String) maxScoreVulnMap.get("VULN_SUMMARY"));
				vuln.setModiDate(String.valueOf((Timestamp) maxScoreVulnMap.get("MODI_DATE")));
				list.add(vuln);
			}
		}
		
		String[] nicknameList = null;
		
		try {
			nicknameList = ossService.getOssNickNameListByOssName(isEmpty(refOssName) ? ossName : refOssName);
			if (underscoreFlag) {
				if (nicknameList != null) {
					List<String> nicknameList2 = new ArrayList<>();
					nicknameList2.addAll(Arrays.asList(nicknameList));
					nicknameList2.add(bean.getOssName());
					nicknameList = nicknameList2.toArray(new String[nicknameList2.size()]);
				}
			}
			
			if (nicknameList != null) {
				List<String> nicknameList2 = new ArrayList<>();
				nicknameList2.addAll(Arrays.asList(nicknameList));
				nicknameList2.add(ossName.replaceAll(" ", "_"));
				nicknameList = nicknameList2.toArray(new String[nicknameList2.size()]);
			} else {
				nicknameList = new String[] {ossName.replaceAll(" ", "_")};
			}
			
			bean.setSchOssName(ossName);
			bean.setOssName(!isEmpty(refOssName) ? refOssName : ossName);
			bean.setOssNicknames(nicknameList);
			
//			List<Vulnerability> list2 = vulnerabilityMapper.selectOssVulnerabilityListByVersionAlias(bean);
//			if (list2 != null && !list2.isEmpty()) {
//				checkVulnDataFlag = true;
//				list.addAll(list2);
//			}
			
			List<Vulnerability> list3 = vulnerabilityMapper.getVulnListByOssName2(bean);
			if (list3 != null & !list3.isEmpty()) {
				checkVulnDataFlag = true;
				list.addAll(list3);
			}
			
			if (list != null && !list.isEmpty()) {
				list = list.stream().filter(CommonFunction.distinctByKey(e -> e.getCveId())).collect(Collectors.toList());
				for (Vulnerability vuln : list) {
					vuln.setVersion(bean.getOssVersion());
				}
			}
		} catch (Exception e) {
			log.error(e.getMessage());
		}
		
		if (!checkVulnDataFlag) {
			list = checkVulnData(list, nicknameList);
		}
		
		if (!includeCpeCheckFlag) {
			OssMaster param = new OssMaster();
			List<String> includeCpes = ossMapper.selectOssIncludeCpeList(param);
			List<Vulnerability> customList = new ArrayList<>();
			
			for (Vulnerability vuln : list) {
				if (!includeCpes.contains(vuln.getCriteria())) {
					customList.add(vuln);
				}
			}
			
			list = customList;
		}
		
		if (bean.getVulnerabilityCheckFlag() != null) list = sortDataForVulnerabilityResolution(list);
		
		result.put("page", bean.getCurPage());
		result.put("total", bean.getTotBlockSize());
		result.put("records", list.size()); // total cnt를 cveCnt에 담아두고 관리함.
		result.put("rows", list);
		
		return result;
	}
	
	private List<Vulnerability> sortDataForVulnerabilityResolution(List<Vulnerability> list) {
		List<Vulnerability> vrFixedDataList = new ArrayList<>();
		List<Vulnerability> vrNotFixedDataList = new ArrayList<>();
		
		for (Vulnerability vuln : list) {
			if (vuln.getVulnerabilityResolution() != null && vuln.getVulnerabilityResolution().equals("Fixed")) {
				vrFixedDataList.add(vuln);
			} else {
				vrNotFixedDataList.add(vuln);
			}
		}
		
		if (vrFixedDataList.isEmpty()) {
			return list;
		} else {
			List<Vulnerability> sortedDataList = new ArrayList<>();
			sortedDataList.addAll(vrNotFixedDataList);
			sortedDataList.addAll(vrFixedDataList);
			return sortedDataList;
		}
	}

	public List<Vulnerability> checkVulnData(List<Vulnerability> list, String[] nicknameList){
		List<Vulnerability> result = new ArrayList<Vulnerability>();
		String vulnSummary = "";
		
		for (Vulnerability bean : list) {
			bean.setOssNameAllSearchFlag(CoConstDef.FLAG_YES);
			if (nicknameList != null) {
				bean.setOssNicknames(nicknameList);
			}
			
			int vulnCnt = vulnerabilityMapper.checkVulnDataCnt(bean);
			if (vulnCnt > 0) {
				result.add(bean);
			}
			bean.setVulnSummary(vulnSummary);
		}
		
		return result;
	}
	
	@SuppressWarnings("unused")
	public void doSyncOSSNvdInfo() {

		vulnerabilityMapper.updateOssRecheckVulnFlag();

		List<String> notUsedOssList = new ArrayList<>();
		Map<String, OssMaster> reCalcOssInfoMap = new HashMap<>();
		Map<String, Map<String, OssMaster>> reCalcCommentsOssInfoMap = new HashMap<>();
		Map<String, List<Map<String, Object>>> discoveredCommentsOssInfoMap = new HashMap<>();
		Map<String, String> _filteredNvdData = new HashMap<>();
		List<String> _prjMailList = new ArrayList<>();
		List<String> _reCalcPrjMailList = new ArrayList<>();
		List<String> _removeReCalcPrjMailList = new ArrayList<>();
		Map<String, OssMaster> ossInfoMap = CoCodeManager.OSS_INFO_BY_ID;
		Map<String, String> ossInfoNamesMap = CoCodeManager.OSS_INFO_UPPER_NAMES;
		List<String> checkedOssList = new ArrayList<>();
		List<Map<String, Object>> _nvdInfoDiffVendorList = new ArrayList<>();
		boolean discoveredMailingFlag = false;
		boolean hasNvdData = vulnerabilityMapper.selectNvdTotalCount() > 0;
		T2CodeDtl codeDetail = codeMapper.getCodeDetail(CoConstDef.CD_VULNERABILITY_MAILING_SCORE, CoConstDef.CD_VULNERABILITY_MAILING_SCORE_STANDARD);
		String standardScore = codeDetail.getCdDtlExp();
		
		List<String> nvdInfoKeyList = new ArrayList<>();
		List<String> nvdInfoValueList = new ArrayList<>();
		List<String> notMatchDiffVendorList = new ArrayList<>();
		Map<String, List<String>> diffVendorList = new HashMap<>();
		List<String> includeCpeMatchOssIdList = new ArrayList<>();
		Map<String, List<Map<String, Object>>> checkDiffVendor = new HashMap<>();
		
		scheduler_log.info("doSyncOSSNvdInfo standard cvss score : " + standardScore);
		
		List<String> includeCpeEnvironmentList = null;
		List<String> excludeCpeEnvironmentList = null;
		
		List<String> includeCpeAll = vulnerabilityMapper.getOssIncludeCpeAll();
		List<String> excludeCpeAll = vulnerabilityMapper.getOssExcludeCpeAll();
		Map<String, OssMaster> notIncludeCpeMatchOssInfoMap = new HashMap<>();
		
		// include cpe matching
		for (String ossKey : ossInfoMap.keySet()) {
			OssMaster ossBean = ossInfoMap.get(ossKey);
			
			if (!includeCpeAll.contains(ossBean.getOssCommonId()) && !excludeCpeAll.contains(ossBean.getOssCommonId())) {
				notIncludeCpeMatchOssInfoMap.put(ossBean.getOssId(), ossBean);
				continue;
			}
			
			ossBean.setOssVersion(avoidNull(ossBean.getOssVersion()));
			ossBean.setStandardScore(Float.valueOf(standardScore));
			
			List<String> includeCpeList = ossMapper.selectOssIncludeCpeList(ossBean);
			List<String> excludeCpeList = ossMapper.selectOssExcludeCpeList(ossBean);
			
			List<Map<String, Object>> includeVendorProductInfoList = null;
			List<Map<String, Object>> excludeVendorProductInfoList = null;
			List<Map<String, Object>> vendorProductInfoList = null;
			
			includeCpeEnvironmentList = new ArrayList<>();
			excludeCpeEnvironmentList = new ArrayList<>();
			
			if (includeCpeList != null && !includeCpeList.isEmpty()) {
				for (String includeCpe : includeCpeList) {
					if (includeCpe.contains(":")) {
						String[] includeCpeSplit = includeCpe.split("[:]");
						String diffVendorKey = "";
						if (includeCpeSplit.length > 2) {
							diffVendorKey = (includeCpeSplit[3] + "|" + includeCpeSplit[4]).toUpperCase();
						} else {
							diffVendorKey = (includeCpeSplit[0] + "|" + includeCpeSplit[1]).toUpperCase();
						}
						if (!notMatchDiffVendorList.contains(diffVendorKey)) {
							notMatchDiffVendorList.add(diffVendorKey);
						}
					}
				}
				
				List<String> ossVersionAlias = ossMapper.selectOssVersionAliases(ossBean);
				List<String> ossVersionAliasWithoutColon = new ArrayList<>();
				
				if (ossVersionAlias != null && !ossVersionAlias.isEmpty()) {
					List<String> ossVersionAliasWithColon = new ArrayList<>();
					for (String alias : ossVersionAlias) {
						if (alias.contains(":")) {
							ossVersionAliasWithColon.add(alias);
						} else {
							ossVersionAliasWithoutColon.add(alias);
						}
					}
					ossBean.setOssVersionAliasWithColon(ossVersionAliasWithColon.toArray(new String[ossVersionAliasWithColon.size()]));
				}
				ossVersionAliasWithoutColon.add(isEmpty(ossBean.getOssVersion()) ? "-" : ossBean.getOssVersion());
				ossBean.setOssVersionAliases(ossVersionAliasWithoutColon.toArray(new String[ossVersionAliasWithoutColon.size()]));
				
				generateIncludeCpeParam(ossBean, includeCpeList, includeCpeEnvironmentList);
				includeVendorProductInfoList = vulnerabilityMapper.selectVendorProductByCpeInfo(ossBean);
				
				if (excludeCpeList != null && !excludeCpeList.isEmpty()) {
					generateExcludeCpeParam(ossBean, excludeCpeList, excludeCpeEnvironmentList);
					excludeVendorProductInfoList = vulnerabilityMapper.selectVendorProductByCpeInfo(ossBean);
				}
				
				List<Map<String, Object>> filteredVendorProductInfoList = new ArrayList<>();
				if (includeVendorProductInfoList != null && !includeVendorProductInfoList.isEmpty()) {
					if (excludeVendorProductInfoList != null && !excludeVendorProductInfoList.isEmpty()) {
						generateIncludeCpeMatchList(includeVendorProductInfoList, excludeVendorProductInfoList, includeCpeEnvironmentList, filteredVendorProductInfoList, notMatchDiffVendorList);
					} else {
						generateIncludeCpeMatchList(includeVendorProductInfoList, null, includeCpeEnvironmentList, filteredVendorProductInfoList, null);
					}
				}
				
				List<String> filteredKeyList = new ArrayList<>();
				if (excludeVendorProductInfoList != null) {
					for (Map<String, Object> excludeMap : excludeVendorProductInfoList) {
						String criteria = (String) excludeMap.get("CRITERIA");
						String[] criteriaSplit = criteria.split("[:]");
						String key = (criteriaSplit[4] + "|" + criteriaSplit[5] + "|" + criteriaSplit[3] + "|" + (String) excludeMap.get("CVE_ID")).toUpperCase();
						if (!filteredKeyList.contains(key)) filteredKeyList.add(key);
					}
				}
				
				if (filteredVendorProductInfoList != null && !filteredVendorProductInfoList.isEmpty()) {
					List<Map<String, Object>> filteredNvdDataInfoList = filteredNvdData(_filteredNvdData, filteredVendorProductInfoList, true);
					if (filteredNvdDataInfoList != null && !filteredNvdDataInfoList.isEmpty()) {
						List<Map<String, Object>> rtnNvdInfoSndMailList = insertDataForDiscoveredMailing(ossBean, standardScore, true);
						Map<String, Object> map = filteredNvdDataInfoList.get(0);
						
						Map<String, Object> productVersionMap = generateNvdInfoForProduct(ossBean, _filteredNvdData, filteredKeyList, ossVersionAlias);
						if (productVersionMap != null && !productVersionMap.isEmpty()) {
							BigDecimal includeScore = new BigDecimal(String.valueOf(map.get("CVSS_SCORE")));
							BigDecimal productScore = new BigDecimal(String.valueOf(productVersionMap.get("CVSS_SCORE")));
							if (productScore.compareTo(includeScore) > 0) {
								map.put("CVE_ID", productVersionMap.get("CVE_ID"));
								map.put("CVSS_SCORE", productVersionMap.get("CVSS_SCORE"));
							}
						}
						
						updateVulnAndMailing(ossBean, map, standardScore, _prjMailList, _reCalcPrjMailList, notUsedOssList, reCalcOssInfoMap, reCalcCommentsOssInfoMap, discoveredCommentsOssInfoMap, rtnNvdInfoSndMailList, true);
						checkedOssList.add(ossBean.getOssId());
						String cveId = (String) map.get("CVE_ID");
						if (!_filteredNvdData.containsKey(cveId)) {
							_filteredNvdData.put(cveId, (String) map.get("PRODUCT"));
						}
					}
				}
				
				filteredKeyList = null;
			} else {
				if (excludeCpeList != null && !excludeCpeList.isEmpty()) {
					generateExcludeCpeParam(ossBean, excludeCpeList, excludeCpeEnvironmentList);
					
					List<String> ossVersionAlias = ossMapper.selectOssVersionAliases(ossBean);
					List<String> ossVersionAliasWithoutColon = new ArrayList<>();
					
					if (ossVersionAlias != null && !ossVersionAlias.isEmpty()) {
						List<String> ossVersionAliasWithColon = new ArrayList<>();
						for (String alias : ossVersionAlias) {
							if (alias.contains(":")) {
								ossVersionAliasWithColon.add(alias);
							} else {
								ossVersionAliasWithoutColon.add(alias);
							}
						}
						
						ossVersionAliasWithoutColon.add(isEmpty(ossBean.getOssVersion()) ? "-" : ossBean.getOssVersion());
						ossBean.setOssVersionAliasWithColon(ossVersionAliasWithColon.toArray(new String[ossVersionAliasWithColon.size()]));
						ossBean.setOssVersionAliases(ossVersionAliasWithoutColon.toArray(new String[ossVersionAliasWithoutColon.size()]));
						
						ossVersionAliasWithColon = null;
						ossVersionAliasWithoutColon = null;
					} else {
						ossVersionAlias.add(isEmpty(ossBean.getOssVersion()) ? "-" : ossBean.getOssVersion());
						ossBean.setOssVersionAliases(ossVersionAlias.toArray(new String[ossVersionAlias.size()]));
					}
					
					excludeVendorProductInfoList = vulnerabilityMapper.selectVendorProductByCpeInfo(ossBean);
					generateIncludeCpeMatchList(includeVendorProductInfoList, excludeVendorProductInfoList, includeCpeEnvironmentList, null, notMatchDiffVendorList);
				}
			}
			
			includeCpeEnvironmentList = null;
			excludeCpeEnvironmentList = null;
		}
		
		List<String> diffVendorKeyList = new ArrayList<>();
		for (String ossKey : notIncludeCpeMatchOssInfoMap.keySet()) {
			OssMaster ossBean = notIncludeCpeMatchOssInfoMap.get(ossKey);
			
			if (checkedOssList.contains(ossBean.getOssId())) continue;
			
			List<String> excludeCpeList = ossMapper.selectOssExcludeCpeList(ossBean);
			List<String> ossVersionAlias = ossMapper.selectOssVersionAliases(ossBean);
			List<String> ossVersionAliasWithoutColon = new ArrayList<>();
			
			if (ossVersionAlias != null && !ossVersionAlias.isEmpty()) {
				List<String> ossVersionAliasWithColon = new ArrayList<>();
				for (String alias : ossVersionAlias) {
					if (alias.contains(":")) {
						ossVersionAliasWithColon.add(alias);
					} else {
						ossVersionAliasWithoutColon.add(alias);
					}
				}
				ossBean.setOssVersionAliasWithColon(ossVersionAliasWithColon.toArray(new String[ossVersionAliasWithColon.size()]));
			}
			ossVersionAliasWithoutColon.add(isEmpty(ossBean.getOssVersion()) ? "-" : ossBean.getOssVersion());
			ossBean.setOssVersionAliases(ossVersionAliasWithoutColon.toArray(new String[ossVersionAliasWithoutColon.size()]));
			
			ossVersionAliasWithoutColon = null;
			List<Map<String, Object>> excludeVendorProductInfoList = null;
			List<Map<String, Object>> vendorProductInfoList = null;
			List<String> filteredKeyList = new ArrayList<>();
			
			if (excludeCpeList != null && !excludeCpeList.isEmpty()) {
				List<String> excludCpeCheckList = new ArrayList<>();
				for (String excludeCpe : excludeCpeList) {
					if (excludeCpe.contains(":")) {
						String[] excludeCpeSplit = excludeCpe.split("[:]");
						String diffVendorKey = "";
						if (excludeCpeSplit.length > 2) {
							diffVendorKey = (excludeCpeSplit[3] + "|" + excludeCpeSplit[4]).toUpperCase();
						} else {
							diffVendorKey = (excludeCpeSplit[0] + "|" + excludeCpeSplit[1]).toUpperCase();
						}
						excludCpeCheckList.add(diffVendorKey);
					}
				}
				
				generateExcludeCpeParam(ossBean, excludeCpeList, excludeCpeEnvironmentList);
				excludeVendorProductInfoList = vulnerabilityMapper.selectVendorProductByCpeInfo(ossBean);
				if (excludeVendorProductInfoList != null && !excludeVendorProductInfoList.isEmpty()) {
					for (Map<String, Object> excludeMap : excludeVendorProductInfoList) {
						String criteria = (String) excludeMap.get("CRITERIA");
						String[] criteriaSplit = criteria.split("[:]");
						String key = (criteriaSplit[4] + "|" + criteriaSplit[5] + "|" + criteriaSplit[3] + "|" + (String) excludeMap.get("CVE_ID")).toUpperCase();
						if (!filteredKeyList.contains(key)) filteredKeyList.add(key);
						
						String vendorKey = (criteriaSplit[3] + "|" + criteriaSplit[4]).toUpperCase();
						if (!notMatchDiffVendorList.contains(vendorKey)) notMatchDiffVendorList.add(vendorKey);
					}
					
					excludeVendorProductInfoList = null;
				}
			}
			
			checkedOssList.add(ossBean.getOssId());
			ossBean.setOssVersion(avoidNull(ossBean.getOssVersion()));
			ossBean.setStandardScore(Float.valueOf(standardScore));
			boolean reCheckNVDInfo = false;
			
			if (!isEmpty(ossBean.getOssVersion())) {
				List<Map<String, Object>> nvdInfoList = vulnerabilityMapper.selectNvdInfo(ossBean);
				if (nvdInfoList != null && !nvdInfoList.isEmpty()) {
				} else {
					if (ossBean.getOssVersionAliases() != null) {
						for (String versionAlias : ossBean.getOssVersionAliases()) {
							ossBean.setOssVersion(versionAlias);
							List<Map<String, Object>> nvdInfoList2 = vulnerabilityMapper.selectNvdInfo(ossBean);
							if (nvdInfoList2 != null && !nvdInfoList2.isEmpty()) {
								if (nvdInfoList == null) nvdInfoList = new ArrayList<>();
								nvdInfoList.addAll(nvdInfoList2);
							}
						}
					}
				}
//				if (ossVersionAlias != null && !ossVersionAlias.isEmpty()) {
//					nvdInfoList = vulnerabilityMapper.selectNvdInfoByVersionAlias(ossBean);
//				} else {
//					if (ossBean.getOssVersion().contains(":")) {
//						ossBean.setOssVersionAliasWithColon(new String[] {ossBean.getOssVersion()});
//					} else {
//						ossBean.setOssVersionAliases(new String[] {ossBean.getOssVersion()});
//					}
//					nvdInfoList = vulnerabilityMapper.selectNvdInfoByVersionAlias(ossBean);
//					if (nvdInfoList != null && !nvdInfoList.isEmpty()) {
//					} else {
//						nvdInfoList = vulnerabilityMapper.selectNvdInfo(ossBean);
//					}
//					
//					ossBean.setOssVersionAliases(null);
//					ossBean.setOssVersionAliasWithColon(null);
//				}
				
				if (nvdInfoList != null && !nvdInfoList.isEmpty()) {
					if (filteredKeyList != null && !filteredKeyList.isEmpty()) {
						filteredNvdData2(nvdInfoList, filteredKeyList);
					}
					
					List<Map<String, Object>> filteredNvdDataInfoList = filteredNvdData(_filteredNvdData, nvdInfoList, false);
					if (filteredNvdDataInfoList != null && !filteredNvdDataInfoList.isEmpty()) {
						List<Map<String, Object>> rtnNvdInfoSndMailList = insertDataForDiscoveredMailing(ossBean, standardScore, false);
						Map<String, Object> map = filteredNvdDataInfoList.get(0);
						updateVulnAndMailing(ossBean, map, standardScore, _prjMailList, _reCalcPrjMailList, notUsedOssList, reCalcOssInfoMap, reCalcCommentsOssInfoMap, discoveredCommentsOssInfoMap, rtnNvdInfoSndMailList, false);
						generateDiffVendor(ossBean, map, nvdInfoKeyList, nvdInfoValueList, diffVendorList, notMatchDiffVendorList);
					} else {
						// NVD 삭제 여부를 체크한다.
						reCheckNVDInfo = true;
					}
				} else {
					// NVD 삭제 여부를 체크한다.
					reCheckNVDInfo = true;
				}
			} else {
				List<Map<String, Object>> nvdInfoList = vulnerabilityMapper.selectNvdInfoWithOutVer(ossBean);
				if (nvdInfoList != null && !nvdInfoList.isEmpty()) {
				} else {
					nvdInfoList = vulnerabilityMapper.selectNvdInfoWithOutVer2(ossBean);
				}
				
//				if (ossVersionAlias != null && !ossVersionAlias.isEmpty()) {
//					nvdInfoList = vulnerabilityMapper.selectNvdInfoByVersionAlias(ossBean);
//				} else {
//					ossBean.setOssVersionAliases(new String[] {"-"});
//					nvdInfoList = vulnerabilityMapper.selectNvdInfoByVersionAlias(ossBean);
//					if (nvdInfoList != null && !nvdInfoList.isEmpty()) {
//					} else {
//						nvdInfoList = vulnerabilityMapper.selectNvdInfoWithOutVer(ossBean);
//					}
//					ossBean.setOssVersionAliases(null);
//				}
				
				if (nvdInfoList != null && !nvdInfoList.isEmpty()) {
					if (filteredKeyList != null && !filteredKeyList.isEmpty()) {
						filteredNvdData2(nvdInfoList, filteredKeyList);
					}
					
					List<Map<String, Object>> filteredNvdDataInfoList = filteredNvdData(_filteredNvdData, nvdInfoList, false);
					if (filteredNvdDataInfoList != null && !filteredNvdDataInfoList.isEmpty()) {
						List<Map<String, Object>> rtnNvdInfoSndMailList = insertDataForDiscoveredMailing(ossBean, standardScore, false);
						Map<String, Object> nvdInfo = filteredNvdDataInfoList.get(0);
						updateVulnAndMailing(ossBean, nvdInfo, standardScore, _prjMailList, _reCalcPrjMailList, notUsedOssList, reCalcOssInfoMap, reCalcCommentsOssInfoMap, discoveredCommentsOssInfoMap, rtnNvdInfoSndMailList, false);
						generateDiffVendor(ossBean, nvdInfo, nvdInfoKeyList, nvdInfoValueList, diffVendorList, notMatchDiffVendorList);
					} else {
						reCheckNVDInfo = true;
					}
				} else {
					// NVD 삭제 여부를 체크한다.
					reCheckNVDInfo = true;
				}
			}
			
			filteredKeyList = null;
			
			// NVD 정보는 없지만 oss list에 nvd 정보가 이미 설정되어 있는 경우
			// NVD 사이트에서 Excluding 되었을 가능성이 높다 (삭제됨)
			if (reCheckNVDInfo) {
				// 혹시 BATCH에서 오류가 발생하여 NVD_DATA_SCORE_V3 테이블에 DATA 가 등록되지 않은 경우 
				// 모든 NVD DATA가 삭제되는 것을 방지하기 위해서 건수가 0건이상인지 확인한다.
				if (hasNvdData && !isEmpty(ossBean.getCveId())) {
					scheduler_log.info("Vulnerability deleteOssVulnInfo OSS ID : " + ossBean.getOssId());
					// oss list에서 NVD 정보를 삭제한다.
					ossBean.setCvssScoreTo("0");
					ossBean.setCveIdTo("");
					vulnerabilityMapper.insertNvdOssHis(ossBean);
					vulnerabilityMapper.deleteOssVulnInfo(ossBean.getOssId());
					
					BigDecimal bdOrgMasterScore = new BigDecimal(String.valueOf(ossBean.getCvssScore()));
					
					// vulnerability mail > base score changed from 9.0 to 8.0
					if (bdOrgMasterScore.compareTo(new BigDecimal(standardScore)) > -1) {
						String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
						ossBean.setOssNames(nickNameList);
						List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
						if (_prjList != null && !_prjList.isEmpty()) {
							_removeReCalcPrjMailList.addAll(_prjList);
						}
						
						reCalcOssInfoMap.put(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion(), ossBean);
					}
				}
			}
			
			// check same product diff vendor
//			if (!diffVendorKeyList.contains(ossBean.getOssName())) {
//				customDiffVendor(ossBean, nvdInfoKeyList, nvdInfoValueList, diffVendorKeyList, diffVendorList, ossInfoNamesMap, notNvdInfoKeyList);
//			}
		}
		
		notIncludeCpeMatchOssInfoMap = null;
		
		if (!diffVendorList.isEmpty()) {
			String vendor = "";
			String cveId = "";
			String linkUrl = CommonFunction.emptyCheckProperty("server.domain", "http://fosslight.org") + "/oss/edit/";
			
			OssMaster param = new OssMaster();
			for (String diffVendorKey : diffVendorList.keySet()) {
				List<String> diffVendor = diffVendorList.get(diffVendorKey);
				diffVendor = diffVendor.stream().distinct().collect(Collectors.toList());
				
//				String[] ossInfo = diffVendorKey.split("\\|");
				param.setOssName(diffVendorKey);
				OssMaster bean = ossMapper.checkExistsOssname(param);
				String product = "<a href=\"" + linkUrl + bean.getOssId() + "\" target=\"_blank\">" + diffVendorKey + "</a>";
				
				if (diffVendor != null && !diffVendor.isEmpty() && diffVendor.size() > 1) {
					Map<String, Object> map = new HashMap<>();
					
					for (int i=0; i < diffVendor.size(); i++) {
						vendor += diffVendor.get(i).split("[|]")[0] + ":" + diffVendor.get(i).split("[|]")[1];
						
						String cveIdString = diffVendor.get(i).split("[|]")[2];
						cveId += "<a href=\"https://nvd.nist.gov/vuln/detail/" + cveIdString + "\" target=\"_blank\">" + cveIdString + "</a>";
						
						if (i < diffVendor.size()-1) {
							vendor += "<br/>";
							cveId += "<br/>";
						}
					}
					
					map.put("product", product);
					map.put("cveId", cveId);
					map.put("vendor", vendor);
					
					_nvdInfoDiffVendorList.add(map);
					
					vendor = "";
					cveId = "";
				}
			}
		}
		
		CoCodeManager.getInstance().refreshOssInfo();
		
		int discoveredOssCnt = 0;
		String securityComment;
		if (_prjMailList != null && !_prjMailList.isEmpty()) {
			discoveredMailingFlag = true;
			
			List<String> prjMailList = new ArrayList<String>(new HashSet<String>(_prjMailList));
			scheduler_log.info("Vulnerability prj COUNT : " + prjMailList.size());
			
			for (String prjId : prjMailList) {
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT);
				String _tempComment = avoidNull(CoCodeManager.getCodeExpString(CoConstDef.CD_MAIL_DEFAULT_CONTENTS, CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT));
				mailBean.setComment(_tempComment);
				mailBean.setParamPrjId(prjId);
				CoMailManager.getInstance().sendMail(mailBean);

				// security tab comment history
				securityComment = "";
				if (discoveredCommentsOssInfoMap.containsKey(prjId)) {
					List<Map<String, Object>> discoveredCommentsInfoList = discoveredCommentsOssInfoMap.get(prjId);
					if (discoveredCommentsInfoList != null && !discoveredCommentsInfoList.isEmpty()) {
						List<String> duplicatedOssNameList = new ArrayList<>();
						securityComment += "<p><strong>Vulnerability discovered</strong>";
						for (Map<String, Object> commentsInfo : discoveredCommentsInfoList) {
							if (ossInfoMap.containsKey(commentsInfo.get("OSS_ID"))) {
								OssMaster om = ossInfoMap.get(commentsInfo.get("OSS_ID"));
								String key = (om.getOssName() + "_" + avoidNull(om.getOssVersion(), "N/A") + "_" + (String) commentsInfo.get("CVE_ID")).toUpperCase();
								if (!duplicatedOssNameList.contains(key)) {
									securityComment += "<br />" + om.getOssName() + " (" + avoidNull(om.getOssVersion(), "N/A") + ") : " + CommonFunction.convertCveIdToLink((String) commentsInfo.get("CVE_ID"));
									duplicatedOssNameList.add(key);
								}
							}
						}
					}
				}
				
				if (discoveredCommentsOssInfoMap.containsKey(prjId) && reCalcCommentsOssInfoMap.containsKey(prjId)) {
					Map<String, OssMaster> reCalcCommentsInfo = reCalcCommentsOssInfoMap.get(prjId);
					if (!MapUtils.isEmpty(reCalcCommentsInfo)) {
						List<String> duplicatedOssNameList = new ArrayList<>();
						securityComment += "<br /><br />";
						securityComment += "<strong>Vulnerability recalculated</strong>";
						
						for(String reCalcInfo : reCalcCommentsInfo.keySet() ){
							if (reCalcCommentsInfo.containsKey(reCalcInfo)) {
								OssMaster om = reCalcCommentsInfo.get(reCalcInfo);
								String key = (om.getOssName() + "_" + avoidNull(om.getOssVersion(), "N/A") + "_" + om.getCveId()).toUpperCase();
								if (!duplicatedOssNameList.contains(key)) {
									securityComment += "<br />" + om.getOssName() + " (" + avoidNull(om.getOssVersion(), "N/A") + ") : " + CommonFunction.convertCveIdToLink(om.getCveId());
									duplicatedOssNameList.add(key);
								}
							}
						}
					}
				}
				
				if (!isEmpty(securityComment)) {
					securityComment += "</p>";
					
					CommentsHistory commHisBean = new CommentsHistory();
					commHisBean.setReferenceDiv(CoConstDef.CD_DTL_COMMENT_SECURITY_HIS);
					commHisBean.setReferenceId(prjId);
					commHisBean.setContents(securityComment);
					commHisBean.setLoginUserName("oscAdmin");
					
					commentService.registComment(commHisBean, false);
				}
			}
		}
		
		if (_reCalcPrjMailList != null && !_reCalcPrjMailList.isEmpty()) {
			List<String> prjMailList = new ArrayList<String>(new HashSet<String>(_reCalcPrjMailList));
			scheduler_log.info("Vulnerability risk recalculated prj COUNT : " + _reCalcPrjMailList.size());
			for (String prjId : prjMailList) {
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT_RECALCULATED);
				String _tempComment = avoidNull(CoCodeManager.getCodeExpString(CoConstDef.CD_MAIL_DEFAULT_CONTENTS, CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT_RECALCULATED));
				mailBean.setComment(_tempComment);
				mailBean.setParamPrjId(prjId);
				mailBean.setParamStandardScore(standardScore);
				mailBean.setParamOssInfoMap(reCalcOssInfoMap);
				CoMailManager.getInstance().sendMail(mailBean);
				
				// security tab comment history
				securityComment = "";
				if (!discoveredCommentsOssInfoMap.containsKey(prjId) && reCalcCommentsOssInfoMap.containsKey(prjId)) {
					Map<String, OssMaster> reCalcCommentsInfo = reCalcCommentsOssInfoMap.get(prjId);
					
					if (!MapUtils.isEmpty(reCalcCommentsInfo)) {
						securityComment += "<p><strong>Vulnerability recalculated</strong>";
						for(String key : reCalcCommentsInfo.keySet() ){
							OssMaster om = reCalcCommentsInfo.get(key);
							securityComment += "<br />" + om.getOssName() + " (" + avoidNull(om.getOssVersion(), "N/A") + ") : " + CommonFunction.convertCveIdToLink(om.getCveId());
						}
						securityComment += "</p>";
						
						CommentsHistory commHisBean = new CommentsHistory();
						commHisBean.setReferenceDiv(CoConstDef.CD_DTL_COMMENT_SECURITY_HIS);
						commHisBean.setReferenceId(prjId);
						commHisBean.setContents(securityComment);
						commHisBean.setLoginUserName("oscAdmin");
						
						commentService.registComment(commHisBean, false);
					}
				}
			}
			
		}
		
		if (_removeReCalcPrjMailList != null && !_removeReCalcPrjMailList.isEmpty()) {
			List<String> prjMailList = new ArrayList<String>(new HashSet<String>(_removeReCalcPrjMailList));
			scheduler_log.info("Vulnerability risk remove > recalculated prj COUNT : " + _removeReCalcPrjMailList.size());
			for (String prjId : prjMailList) {
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT_REMOVE_RECALCULATED);
				String _tempComment = avoidNull(CoCodeManager.getCodeExpString(CoConstDef.CD_MAIL_DEFAULT_CONTENTS, CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT_REMOVE_RECALCULATED));
				mailBean.setComment(_tempComment);
				mailBean.setParamPrjId(prjId);
				mailBean.setParamStandardScore(standardScore);
				mailBean.setParamOssInfoMap(reCalcOssInfoMap);
				CoMailManager.getInstance().sendMail(mailBean);
			}
			
		}
		
		if (!notUsedOssList.isEmpty()) {
			discoveredMailingFlag = true;
			discoveredOssCnt = notUsedOssList.size();
			
			try {
				scheduler_log.info("Vulnerability notUsedOssList COUNT : " + notUsedOssList.size());
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_OSS);
				mailBean.setParamOssKey(notUsedOssList);
				CoMailManager.getInstance().sendMail(mailBean);
			} catch (Exception e) {
				scheduler_log.error(e.getMessage(), e);
			}
		}
		
		if (reCalcOssInfoMap.keySet().size() > 0) {
			try {
				scheduler_log.info("Vulnerability reCalculated All COUNT : " + reCalcOssInfoMap.keySet().size());
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT_RECALCULATED_ALL);
				ArrayList<String> keyList = new ArrayList<String>(reCalcOssInfoMap.keySet());
				mailBean.setParamOssKey(keyList);
				CoMailManager.getInstance().sendMail(mailBean);
			} catch (Exception e) {
				scheduler_log.error(e.getMessage(), e);
			}
		}
		
		if (_nvdInfoDiffVendorList != null && _nvdInfoDiffVendorList.size() > 0) {
			try {
				scheduler_log.info("Vulnerability nvdInfoDiffVendorList COUNT : " + _nvdInfoDiffVendorList.size());
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_NVDINFO_DIFF);
				mailBean.setParamList(_nvdInfoDiffVendorList);
				CoMailManager.getInstance().sendMail(mailBean);
			} catch (Exception e) {
				scheduler_log.error(e.getMessage(), e);
			}
		}
		
		if (discoveredMailingFlag) {
			scheduler_log.info("Vulnerability Discovered OSS COUNT : " + discoveredOssCnt);
			try {
				vulnerabilityMapper.updateOssDiscoveredSndEmail();
			} catch (Exception e) {
				scheduler_log.error(e.getMessage(), e);
			}
		}
	}

	private void generateDiffVendor(OssMaster ossBean, Map<String, Object> nvdInfo, List<String> nvdInfoKeyList, List<String> nvdInfoValueList, Map<String, List<String>> diffVendorList, List<String> notMatchDiffVendorList) {
		String product = (String) nvdInfo.get("PRODUCT");
		if (CoCodeManager.OSS_INFO_UPPER_NAMES.containsKey(product.toUpperCase())) {
			product = CoCodeManager.OSS_INFO_UPPER_NAMES.get(product.toUpperCase());
		} else {
			if (CoCodeManager.OSS_INFO_UPPER_NAMES.containsKey(product.replaceAll("_", " ").toUpperCase())) {
				product = CoCodeManager.OSS_INFO_UPPER_NAMES.get(product.replaceAll("_", " ").toUpperCase());
			}
		}
		String nvdInfoKey = ((String) nvdInfo.get("VENDOR") + "|" + product).toUpperCase();
		String diffVendorKey = ossBean.getOssName();
		
		if (!notMatchDiffVendorList.contains(nvdInfoKey) && !nvdInfoKeyList.contains(nvdInfoKey)) {
			nvdInfoKeyList.add(nvdInfoKey);
			
			if (diffVendorList.containsKey(diffVendorKey)) {
				nvdInfoValueList = diffVendorList.get(diffVendorKey);
			} else {
				nvdInfoValueList = new ArrayList<>();
			}
			
			nvdInfoValueList.add((String) nvdInfo.get("VENDOR") + "|" + (String) nvdInfo.get("PRODUCT") + "|" + (String) nvdInfo.get("CVE_ID"));
			diffVendorList.put(ossBean.getOssName(), nvdInfoValueList);
		}
	}

	private Map<String, Object> generateNvdInfoForProduct(OssMaster ossBean, Map<String, String> _filteredNvdData, List<String> filteredKeyList, List<String> ossVersionAlias) {
		List<Map<String, Object>> nvdInfoList = null;
		Map<String, Object> map = null;
		
		if (!isEmpty(ossBean.getOssVersion())) {
			nvdInfoList = vulnerabilityMapper.selectNvdInfoByVersionAlias(ossBean);
			if (nvdInfoList != null && !nvdInfoList.isEmpty()) {
			} else {
				nvdInfoList = vulnerabilityMapper.selectNvdInfo(ossBean);
			}
			if (nvdInfoList != null && !nvdInfoList.isEmpty()) {
				if (filteredKeyList != null && !filteredKeyList.isEmpty()) {
					filteredNvdData2(nvdInfoList, filteredKeyList);
				}
				
				if (nvdInfoList != null && !nvdInfoList.isEmpty()) {
					List<Map<String, Object>> filteredList = filteredNvdData(_filteredNvdData, nvdInfoList, true);
					map = filteredList.get(0);
				}
			}
		} else {
			nvdInfoList = vulnerabilityMapper.selectNvdInfoByVersionAlias(ossBean);
			if (nvdInfoList != null && !nvdInfoList.isEmpty()) {
			} else {
				nvdInfoList = vulnerabilityMapper.selectNvdInfoWithOutVer(ossBean);
			}
			if (nvdInfoList != null && !nvdInfoList.isEmpty()) {
				if (filteredKeyList != null && !filteredKeyList.isEmpty()) {
					filteredNvdData2(nvdInfoList, filteredKeyList);
				}
				
				if (nvdInfoList != null && !nvdInfoList.isEmpty()) {
					List<Map<String, Object>> filteredList = filteredNvdData(_filteredNvdData, nvdInfoList, true);
					map = filteredList.get(0);
				}
			}
		}
		return map;
	}

	private void filteredNvdData2(List<Map<String, Object>> nvdInfoList, List<String> filteredKeyList) {
		List<Map<String, Object>> filteredNvdInfoList = new ArrayList<>();
		
		for (Map<String, Object> nvdInfo : nvdInfoList) {
			String key = ((String) nvdInfo.get("PRODUCT") + "|" + (String)nvdInfo.get("VERSION") + "|" + (String)nvdInfo.get("VENDOR") + "|" + (String)nvdInfo.get("CVE_ID")).toUpperCase();
			if (!filteredKeyList.contains(key)) filteredNvdInfoList.add(nvdInfo);
		}
		
		nvdInfoList = filteredNvdInfoList;
	}

	private void generateIncludeCpeMatchList(List<Map<String, Object>> includeVendorProductInfoList, List<Map<String, Object>> excludeVendorProductInfoList, List<String> includeCpeEnvironmentList, List<Map<String, Object>> filteredVendorProductInfoList, List<String> notMatchDiffVendorList) {
		List<String> filteredKeyList = null;
		boolean excludeListFlag = false;

		if (excludeVendorProductInfoList != null && !excludeVendorProductInfoList.isEmpty()) {
			excludeListFlag = true;
			filteredKeyList = new ArrayList<>();
			
			for (Map<String, Object> excludeMap : excludeVendorProductInfoList) {
				String criteria = (String) excludeMap.get("CRITERIA");
				String[] criteriaSplit = criteria.split("[:]");
				filteredKeyList.add((criteriaSplit[4] + "|" + criteriaSplit[5] + "|" + criteriaSplit[3] + "|" + (String) excludeMap.get("CVE_ID")).toUpperCase());
				
				String vendorKey = (criteriaSplit[3] + "|" + criteriaSplit[4]).toUpperCase();
				if (notMatchDiffVendorList != null && !notMatchDiffVendorList.contains(vendorKey)) notMatchDiffVendorList.add(vendorKey);
			}
		}
		
		if (includeVendorProductInfoList != null && !includeVendorProductInfoList.isEmpty()) {
			for (Map<String, Object> includeVendorProductInfo : includeVendorProductInfoList) {
//				String diffVendorKey = ((String) includeVendorProductInfo.get("VENDOR") + "|" + (String) includeVendorProductInfo.get("PRODUCT")).toUpperCase();
//				if (!notNvdInfoKeyList.contains(diffVendorKey)) {
//					notNvdInfoKeyList.add(diffVendorKey);
//				}
				
				if (excludeListFlag) {
					String criteria = (String) includeVendorProductInfo.get("CRITERIA");
					String[] criteriaSplit = criteria.split("[:]");
					
					String key = criteriaSplit[4] + "|" + criteriaSplit[5] + "|" + criteriaSplit[3] + "|" + (String) includeVendorProductInfo.get("CVE_ID");
					if (!filteredKeyList.contains(key.toUpperCase())) {
						checkIncludeCpeEnvironment(includeVendorProductInfo, includeCpeEnvironmentList, filteredVendorProductInfoList);
					}
				} else {
					checkIncludeCpeEnvironment(includeVendorProductInfo, includeCpeEnvironmentList, filteredVendorProductInfoList);
				}
			}
		}
		
		filteredKeyList = null;
	}

	private void checkIncludeCpeEnvironment(Map<String, Object> includeVendorProductInfo, List<String> includeCpeEnvironmentList, List<Map<String, Object>> filteredVendorProductInfoList) {
		String criteria = (String) includeVendorProductInfo.get("CRITERIA");
		String[] criteriaSplit = criteria.split("[:]");
		int cpeIdx = 0;
		String criteriaEnvironment = "";
		
		for (String cpe : criteriaSplit) {
			if (cpeIdx != 5) {
				criteriaEnvironment += cpe;
				if (cpeIdx != criteriaSplit.length-1) criteriaEnvironment += ":";
			}
			cpeIdx++;
		}
		
		if (includeCpeEnvironmentList != null && !includeCpeEnvironmentList.isEmpty()) {
			if (includeCpeEnvironmentList.contains(criteriaEnvironment)) {
				filteredVendorProductInfoList.add(includeVendorProductInfo);
			}
		} else {
			filteredVendorProductInfoList.add(includeVendorProductInfo);
		}
	}

	private void generateExcludeCpeParam(OssMaster ossBean, List<String> excludeCpeList, List<String> excludeCpeEnvironmentList) {
		ossBean.setIncludeCpe(null);
		ossBean.setIncludeCpes(null);
		
		List<String> excludeCpes = new ArrayList<>();
		String excludeCpeString = "\"";
		int idx = 0;
		for (String excludeCpe : excludeCpeList) {
			int index = 0;
			index = excludeCpe.indexOf("*");
			
			if (excludeCpe.startsWith("cpe:2.3:a") || excludeCpe.startsWith("cpe:2.3:h")) {
				int stringLength = excludeCpe.length();
				int colonLength = excludeCpe.replace(":", "").length();
				if (stringLength - colonLength == 12) {
					String[] excludeCpeSplit = excludeCpe.split("[:]");
					int cpeIdx = 0;
					String excludeCpeEnvironment = "";
					for (String cpe : excludeCpeSplit) {
						if (cpeIdx != 5) {
							excludeCpeEnvironment += cpe;
							if (cpeIdx != excludeCpeSplit.length-1) excludeCpeEnvironment += ":";
						}
						cpeIdx++;
					}
					excludeCpeEnvironmentList.add(excludeCpeEnvironment);
				}
			}
			
			if (index > -1) excludeCpe = excludeCpe.substring(0, index-1);
			if (excludeCpe.startsWith("cpe:2.3:a")) excludeCpe = excludeCpe.replace("cpe:2.3:a", "");
			if (excludeCpe.startsWith("cpe:2.3:h")) excludeCpe = excludeCpe.replace("cpe:2.3:h", "");
			excludeCpeString += excludeCpe;
			excludeCpes.add(excludeCpe);
			if (idx != excludeCpeList.size()-1) {
				excludeCpeString += "\" \"";
			}
			idx++;
		}
		excludeCpeString += "\"";
		ossBean.setExcludeCpe(excludeCpeString);
		ossBean.setExcludeCpes(excludeCpes.toArray(new String[excludeCpes.size()]));
	}

	private void generateIncludeCpeParam(OssMaster ossBean, List<String> includeCpeList, List<String> includeCpeEnvironmentList) {
		List<String> includeCpes = new ArrayList<>();
		String includeCpeString = "\"";
		
		int idx = 0;
		for (String includeCpe : includeCpeList) {
			if (!isEmpty(includeCpe)) {
				int index = 0;
				index = includeCpe.indexOf("*");
				
				if (includeCpe.startsWith("cpe:2.3:a") || includeCpe.startsWith("cpe:2.3:h")) {
					int stringLength = includeCpe.length();
					int colonLength = includeCpe.replace(":", "").length();
					if (stringLength - colonLength == 12) {
						String[] includeCpeSplit = includeCpe.split("[:]");
						int cpeIdx = 0;
						String includeCpeEnvironment = "";
						for (String cpe : includeCpeSplit) {
							if (cpeIdx != 5) {
								includeCpeEnvironment += cpe;
								if (cpeIdx != includeCpeSplit.length-1) includeCpeEnvironment += ":";
							}
							cpeIdx++;
						}
						includeCpeEnvironmentList.add(includeCpeEnvironment);
					}
				}
				
				if (index > -1) includeCpe = includeCpe.substring(0, index-1);
				if (includeCpe.startsWith("cpe:2.3:a:")) includeCpe = includeCpe.replace("cpe:2.3:a:", "").replace("cpe:2.3:h:", "");
				includeCpeString += includeCpe;
				includeCpes.add(includeCpe);
				if (idx != includeCpeList.size()-1) {
					includeCpeString += "\" \"";
				}
				idx++;
			}
		}
		includeCpeString += "\"";
		ossBean.setIncludeCpe(includeCpeString);
		ossBean.setIncludeCpes(includeCpes.toArray(new String[includeCpes.size()]));
	}

	private void customDiffVendor(OssMaster ossBean, List<String> nvdInfoKeyList, List<String> nvdInfoValueList, List<String> diffVendorKeyList, Map<String, List<String>> diffVendorList, Map<String, String> ossInfoNamesMap, List<String> notNvdInfoKeyList) {
		List<Map<String, Object>> diffVendorProductList = null;
//		if (excludeCpeMatchingList != null && !excludeCpeMatchingList.isEmpty()) {
//			diffVendorProductList = excludeCpeMatchingList;
//		} else {
			List<Map<String, Object>> checkDiffVendor = vulnerabilityMapper.selectDiffVendorForProduct(ossBean);
			diffVendorProductList = checkDiffVendor.stream().filter(e -> !ossInfoNamesMap.containsKey((e.get("VENDOR") + "-" + e.get("PRODUCT")).toUpperCase())).collect(Collectors.toList());
//		}
		
		if (diffVendorProductList != null && !diffVendorProductList.isEmpty()) {
			nvdInfoValueList = new ArrayList<>();
			String nvdInfoKey = "";
			for (Map<String, Object> nvdInfo : diffVendorProductList) {
				nvdInfoKey = ((String) nvdInfo.get("VENDOR") + "|" + (String) nvdInfo.get("PRODUCT")).toUpperCase();
				if (!nvdInfoKeyList.contains(nvdInfoKey) && !notNvdInfoKeyList.contains(nvdInfoKey)) {
					nvdInfoKeyList.add(nvdInfoKey);
					nvdInfoValueList.add((String) nvdInfo.get("VENDOR") + "|" + (String) nvdInfo.get("PRODUCT") + "|" + (String) nvdInfo.get("CVE_ID"));
				}
			}
			
			if (nvdInfoValueList != null && !nvdInfoValueList.isEmpty() && nvdInfoValueList.size() > 1) {
				diffVendorKeyList.add(ossBean.getOssName());
				diffVendorList.put(ossBean.getOssName() + "|" + ossBean.getOssId(), nvdInfoValueList);
			}
			nvdInfoValueList = null;
		}
	}

	private List<Map<String, Object>> insertDataForDiscoveredMailing(OssMaster ossBean, String standardScore, boolean vendorProductFlag) {
		List<Map<String, Object>> rtnNvdInfoSndMailList = new ArrayList<>();
		List<Map<String, Object>> nvdInfoSndMailList = null;
		if (vendorProductFlag) {
			nvdInfoSndMailList = vulnerabilityMapper.selectVendorProductSndMailList(ossBean);
		} else {
			nvdInfoSndMailList = vulnerabilityMapper.selectNvdInfoSndMailList(ossBean);
		}
		
		ossBean.setSndMailCheckFlag(CoConstDef.FLAG_YES);
		List<Map<String, Object>> discoveredMailSendList = vulnerabilityMapper.selectDiscoveredSndMailList(ossBean);
		if (discoveredMailSendList != null && !discoveredMailSendList.isEmpty()) {
			List<Map<String, Object>> deduplicatedMailingCheckList = nvdInfoSndMailList.stream()
																	.filter(e -> 
																			discoveredMailSendList.stream()
																			.filter(o -> 
																					((String) e.get("PRODUCT") + "|" + (String) e.get("VERSION") + "|"	+ (String) e.get("CVE_ID") + "|" + ((Float) e.get("CVSS_SCORE")).toString())
																					.equalsIgnoreCase(((String) o.get("PRODUCT") + "|" + (String) o.get("VERSION") + "|" + (String) o.get("CVE_ID") + "|" + ((Float) o.get("CVSS_SCORE")).toString()))
																			).collect(Collectors.toList()).size() == 0
																	).collect(Collectors.toList());
			
			if (deduplicatedMailingCheckList != null && !deduplicatedMailingCheckList.isEmpty()) {
				for (Map<String, Object> mailingInfo : deduplicatedMailingCheckList) {
					mailingInfo.put("OSS_ID", ossBean.getOssId());
					vulnerabilityMapper.insertOssDiscoveredSndEmail(mailingInfo);
					rtnNvdInfoSndMailList.add(mailingInfo);
				}
			}
		} else {
			for (Map<String, Object> mailingInfo : nvdInfoSndMailList) {
				mailingInfo.put("OSS_ID", ossBean.getOssId());
				vulnerabilityMapper.insertOssDiscoveredSndEmail(mailingInfo);
				rtnNvdInfoSndMailList.add(mailingInfo);
			}
		}
		
		return rtnNvdInfoSndMailList;
	}

	private List<Map<String, Object>> filteredNvdData(Map<String, String> _filteredNvdData, List<Map<String, Object>> nvdDataList, boolean fileCheckFlag) {
		List<Map<String, Object>> filteredNvdDataList = new ArrayList<>();
		
		if (fileCheckFlag) {
			filteredNvdDataList.addAll(nvdDataList);
		} else {
			List<Map<String, Object>> checkNvdDataList = new ArrayList<>();
			checkNvdDataList.addAll(nvdDataList);
			for (Map<String, Object> info : checkNvdDataList) {
				String cveId = (String) info.get("CVE_ID");
				if (!_filteredNvdData.containsKey(cveId)) {
					filteredNvdDataList.add(info);
				}
			}
		}
		
		if (filteredNvdDataList != null && !filteredNvdDataList.isEmpty()) {
			if (filteredNvdDataList.size() > 1) {
				Collections.sort(filteredNvdDataList, new Comparator<Map<String, Object>>() {
					@Override
					public int compare(Map<String, Object> o1, Map<String, Object> o2) {
						Float cvssScore1 = (Float) o1.get("CVSS_SCORE");
						Float cvssScore2 = (Float) o2.get("CVSS_SCORE");
						
						if (new BigDecimal(cvssScore1).compareTo(new BigDecimal(cvssScore2)) > 0) {
							return -1;
						} else {
							return 1;
						}
					}
				});
			}
		}
		
		return filteredNvdDataList;
	}

	@Override
	public Map<String, Object> getCveInfo(String cveId) {
		return vulnerabilityMapper.getCveInfo(cveId);
	}
	
	private void updateVulnAndMailing(OssMaster ossBean, Map<String, Object> nvdInfo, String standardScore, List<String> _prjMailList, List<String> _reCalcPrjMailList, List<String> notUsedOssList,
			Map<String, OssMaster> reCalcOssInfoMap, Map<String, Map<String, OssMaster>> reCalcCommentsOssInfoMap, Map<String, List<Map<String, Object>>> discoveredCommentsOssInfoMap, List<Map<String, Object>> rtnNvdInfoSndMailList, boolean inCpeMatchFlag) {
		BigDecimal bdScore = new BigDecimal(String.valueOf(nvdInfo.get("CVSS_SCORE")));
		BigDecimal bdOrgMasterScore = new BigDecimal(CommonFunction.avoidNull(ossBean.getCvssScore(), "0"));
		String cveId = String.valueOf(nvdInfo.get("CVE_ID"));
		
		// 현재 등록되어 있는 score와 cve_id가 일치하지 않으면 업데이트
		if ( !bdScore.equals(bdOrgMasterScore) || !cveId.equals(ossBean.getCveId())) {
			scheduler_log.info("Vulnerability updateOssVulnInfo OSS ID : " + ossBean.getOssId());
			ossBean.setCvssScoreTo(String.valueOf(nvdInfo.get("CVSS_SCORE")));
			ossBean.setCveIdTo(String.valueOf(nvdInfo.get("CVE_ID")));
			vulnerabilityMapper.insertNvdOssHis(ossBean);
			
			OssMaster newNVD = new OssMaster();
			newNVD.setOssId(ossBean.getOssId());
			newNVD.setCvssScore(ossBean.getCvssScoreTo());
			newNVD.setCveId(ossBean.getCveIdTo());
			if (inCpeMatchFlag) newNVD.setInCpeMatchFlag(CoConstDef.FLAG_YES);
			vulnerabilityMapper.updateOssVulnInfoNew(newNVD);
		}

		// score가 7.0 이상인 경우만 메일을 발송
		// 처음으로 9.0 이상 Score가 등록된 경우 (기존 Score가 9.0 미만이고 NVD update score가 9.0 이상인 경우)
		// vulnerability mail > base score changed from 9.0 to 8.0
		// condition change > if the cvss score value matching ossName + ossVersion is 8.0 or higher (new or modify)
//		if (bdScore.compareTo(new BigDecimal(standardScore)) > -1 && bdOrgMasterScore.compareTo(new BigDecimal(standardScore)) < 0) {
		ossBean.setSndMailCheckFlag(CoConstDef.FLAG_NO);
		if (vulnerabilityMapper.checkDiscoveredSndMailCnt(ossBean) > 0) {
			String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
			ossBean.setOssNames(nickNameList);
			List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
			
			if (_prjList != null && !_prjList.isEmpty()) {
				_prjMailList.addAll(_prjList);
				for (String prj : _prjList) {
					if (discoveredCommentsOssInfoMap.containsKey(prj)) {
						List<Map<String, Object>> discoveredCommentsOssInfoList = discoveredCommentsOssInfoMap.get(prj);
						discoveredCommentsOssInfoList.addAll(rtnNvdInfoSndMailList);
						discoveredCommentsOssInfoMap.put(prj, discoveredCommentsOssInfoList);
					} else {
						discoveredCommentsOssInfoMap.put(prj, rtnNvdInfoSndMailList);
					}
				}
			}
			notUsedOssList.add(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion());
		}
		
		// NVD Score가 9.0 미만이면서 기존 Score가 9.0 이상인 경우, Score가 변경되었음을 메일로 통지
		// vulnerability mail > base score changed from 9.0 to 8.0
		if (bdScore.compareTo(new BigDecimal(standardScore)) < 0 && bdOrgMasterScore.compareTo(new BigDecimal(standardScore)) > -1) {
			String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
			ossBean.setOssNames(nickNameList);
			List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
			if (_prjList != null && !_prjList.isEmpty()) {
				_reCalcPrjMailList.addAll(_prjList);
				for (String prj : _prjList) {
					Map<String, OssMaster> reCalcCommentsOssInfo = null;
					if (reCalcCommentsOssInfoMap.containsKey(prj)) {
						reCalcCommentsOssInfo = reCalcCommentsOssInfoMap.get(prj);
					} else {
						reCalcCommentsOssInfo = new HashMap<>();
					}
					
					reCalcCommentsOssInfo.put(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion(), ossBean);
					reCalcCommentsOssInfoMap.put(prj, reCalcCommentsOssInfo);
				}
			}
			reCalcOssInfoMap.put(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion(), ossBean);
		}
	}

	@Override
	public List<String> getPatchLinkForNvdData(String cveId) {
		return vulnerabilityMapper.getPatchLinkForNvdData(cveId);
	}

	@Override
	public List<Vulnerability> getSecurityVulnListByOssName(OssMaster bean) {
		if ("N/A".equals(bean.getOssVersion()) || isEmpty(bean.getOssVersion())) {
			bean.setOssVersion("-");
		}
		
		String securityStandardScore = codeMapper.getCodeDetail(CoConstDef.CD_SECURITY_VULNERABILITY_SCORE, CoConstDef.CD_SECURITY_VULNERABILITY_DETAIL_SCORE).getCdDtlExp();
		List<Vulnerability> list = null;
		String[] nicknameList = null;
		List<String> convertNicknameList = null;
		List<String> vendorProductSearchList = new ArrayList<>();
		boolean convertFlag = false;
		String ossName = null;
		
		try {
			nicknameList = ossService.getOssNickNameListByOssName(bean.getOssName());
			if(nicknameList.length == 0) {
				if (bean.getOssName().contains("_")) {
					ossName = bean.getOssName();
					bean.setOssName(bean.getOssName().replaceAll("_", " "));
				}
				nicknameList = ossService.getOssNickNameListByOssName(bean.getOssName());
			}
			
			if (bean.getOssName().contains("-")) {
				vendorProductSearchList.add(bean.getOssName());
				vendorProductSearchList.add(ossName);
			}
			
			if(nicknameList.length > 0) {
				for (String nick : nicknameList) {
					if (nick.contains(" ")) {
						if (!convertFlag) {
							convertNicknameList = new ArrayList<>();
							convertFlag = true;
						}
						convertNicknameList.add(nick.replaceAll(" ", "_"));
					}
					
					if (nick.contains("-")) {
						vendorProductSearchList.add(nick);
					}
				}
				
				if (convertNicknameList != null && !convertNicknameList.isEmpty()) {
					if (bean.getOssName().contains(" ")) convertNicknameList.add(bean.getOssName().replaceAll(" ", "_"));
					convertNicknameList.addAll(Arrays.asList(nicknameList));
					convertNicknameList = convertNicknameList.stream().distinct().collect(Collectors.toList());
					nicknameList = convertNicknameList.toArray(new String[convertNicknameList.size()]);
				} else {
					if (bean.getOssName().contains(" ")) {
						convertNicknameList = new ArrayList<>();
						convertNicknameList.add(bean.getOssName().replaceAll(" ", "_"));
						convertNicknameList.addAll(Arrays.asList(nicknameList));
						convertNicknameList = convertNicknameList.stream().distinct().collect(Collectors.toList());
						nicknameList = convertNicknameList.toArray(new String[convertNicknameList.size()]);
					}
				}
			} else {
				if (bean.getOssName().contains(" ")) {
					nicknameList = new String[] {bean.getOssName().replaceAll(" ", "_")};
				}
			}
			
			if (vendorProductSearchList != null && !vendorProductSearchList.isEmpty()) {
				bean.setOssNicknameArr(vendorProductSearchList.toArray(new String[vendorProductSearchList.size()]));
			} else {
				bean.setOssNicknameArr(null);
			}
			
			bean.setOssNicknames(nicknameList);
			bean.setSecurityStandardScore(Float.valueOf(securityStandardScore));
			list = vulnerabilityMapper.getSecurityVulnListByOssName(bean);
			list = list.stream().filter(CommonFunction.distinctByKey(e->e.getCveId()+e.getCvssScore())).sorted(Comparator.comparing(Vulnerability::getCvssScore).reversed()).collect(Collectors.toList());
		} catch (Exception e) {
			log.error(e.getMessage());
		}
		
		return list;
	}

	@Override
	public List<Map<String, Object>> getCpeInfoAndRange(String cveId, String ossName) {
		return vulnerabilityMapper.getCpeInfoAndRange(cveId, ossName);
	}

	@Override
	public Vulnerability selectNotFixedCveInfo(OssMaster bean) {
		if ("N/A".equals(bean.getOssVersion()) || isEmpty(bean.getOssVersion())) {
			bean.setOssVersion("-");
		}
		
		Vulnerability vuln = null;
		String[] nicknameList = null;
		List<String> convertNicknameList = null;
		List<String> vendorProductSearchList = new ArrayList<>();
		boolean convertFlag = false;
		String ossName = null;
		
		try {
			nicknameList = ossService.getOssNickNameListByOssName(bean.getOssName());
			if(nicknameList.length == 0) {
				if (bean.getOssName().contains("_")) {
					ossName = bean.getOssName();
					bean.setOssName(bean.getOssName().replaceAll("_", " "));
				}
				nicknameList = ossService.getOssNickNameListByOssName(bean.getOssName());
			}
			
			if (bean.getOssName().contains("-")) {
				vendorProductSearchList.add(bean.getOssName());
				vendorProductSearchList.add(ossName);
			}
			
			if(nicknameList.length > 0) {
				for (String nick : nicknameList) {
					if (nick.contains(" ")) {
						if (!convertFlag) {
							convertNicknameList = new ArrayList<>();
							convertFlag = true;
						}
						convertNicknameList.add(nick.replaceAll(" ", "_"));
					}
					
					if (nick.contains("-")) {
						vendorProductSearchList.add(nick);
					}
				}
				
				if (convertNicknameList != null && !convertNicknameList.isEmpty()) {
					if (bean.getOssName().contains(" ")) convertNicknameList.add(bean.getOssName().replaceAll(" ", "_"));
					convertNicknameList.addAll(Arrays.asList(nicknameList));
					convertNicknameList = convertNicknameList.stream().distinct().collect(Collectors.toList());
					nicknameList = convertNicknameList.toArray(new String[convertNicknameList.size()]);
				} else {
					if (bean.getOssName().contains(" ")) {
						convertNicknameList = new ArrayList<>();
						convertNicknameList.add(bean.getOssName().replaceAll(" ", "_"));
						convertNicknameList.addAll(Arrays.asList(nicknameList));
						convertNicknameList = convertNicknameList.stream().distinct().collect(Collectors.toList());
						nicknameList = convertNicknameList.toArray(new String[convertNicknameList.size()]);
					}
				}
			} else {
				if (bean.getOssName().contains(" ")) {
					nicknameList = new String[] {bean.getOssName().replaceAll(" ", "_")};
				}
			}
			
			if (vendorProductSearchList != null && !vendorProductSearchList.isEmpty()) {
				bean.setOssNicknameArr(vendorProductSearchList.toArray(new String[vendorProductSearchList.size()]));
				vuln = vulnerabilityMapper.selectNotFixedCveInfo(bean);
			}
			
			if (vuln == null) {
				bean.setOssNicknames(nicknameList);
				vuln = vulnerabilityMapper.selectNotFixedCveInfo(bean);
			}
		} catch (Exception e) {
			log.error(e.getMessage());
		}
		
		return vuln;
	}

	@Override
	public boolean getCpeMatchForCpeInfoCnt(Map<String, Object> paramMap) {
		return vulnerabilityMapper.getCpeMatchForCpeInfoCnt(paramMap) > 0 ? true : false;
	}
}
