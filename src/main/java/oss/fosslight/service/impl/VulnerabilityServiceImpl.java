/*
 * Copyright (c) 2021 LG Electronics Inc.
 * SPDX-License-Identifier: AGPL-3.0-only 
 */

package oss.fosslight.service.impl;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

import lombok.extern.slf4j.Slf4j;
import oss.fosslight.CoTopComponent;
import oss.fosslight.common.CoCodeManager;
import oss.fosslight.common.CoConstDef;
import oss.fosslight.common.CommonFunction;
import oss.fosslight.domain.CoMail;
import oss.fosslight.domain.CoMailManager;
import oss.fosslight.domain.OssMaster;
import oss.fosslight.domain.Vulnerability;
import oss.fosslight.repository.OssMapper;
import oss.fosslight.repository.VulnerabilityMapper;
import oss.fosslight.service.OssService;
import oss.fosslight.service.VulnerabilityService;

@Service
@Slf4j
public class VulnerabilityServiceImpl extends CoTopComponent implements VulnerabilityService {
	private static final Logger scheduler_log = LoggerFactory.getLogger("SCHEDULER_LOG");
	
	@Autowired VulnerabilityMapper vulnerabilityMapper;
	@Autowired OssService ossService;
	@Autowired OssMapper ossMapper;
	
	@Override
	public HashMap<String, Object> getVulnerabilityList(Vulnerability vulnerability, boolean exportFlag) {
		HashMap<String, Object> map = new HashMap<String, Object>();
		
		// Table alias 지정이 필요한 칼럼
		Map<String, String> ambiguousMap = new HashMap<>();
		ambiguousMap.put("CVE_ID", "T1");
		String filterCondition = CommonFunction.getFilterToString(vulnerability.getFilters(), ambiguousMap);
		if(!isEmpty(filterCondition)) {
			vulnerability.setFilterCondition(filterCondition);
		}
		
		if(isEmpty(vulnerability.getOssNameAllSearchFlag())) {
			vulnerability.setOssNameAllSearchFlag(CoConstDef.FLAG_NO);
		}
		
		if(CoConstDef.FLAG_YES.equals(vulnerability.getOssNameAllSearchFlag()) && "PRODUCT".equals(vulnerability.getSidx().toUpperCase())) {
			vulnerability.setSidx("version");
			vulnerability.setSord("desc");
		}
		
		String[] nicknameList = ossService.getOssNickNameListByOssName(vulnerability.getProduct());
		if(nicknameList != null) {
			vulnerability.setOssNicknames(nicknameList);
		}
		
		if(vulnerability.getProduct() != null && vulnerability.getProduct().contains("_")) {
			vulnerability.setSpecialCharactersProduct(vulnerability.getProduct().replace("_", "#_"));
		}
		
		int records = vulnerabilityMapper.selectVulnerabilityTotalCount(vulnerability);
		vulnerability.setTotListSize(records);

		List<Vulnerability> list = null;
		if(exportFlag) {
			list = vulnerabilityMapper.selectVulnerabilityExportList(vulnerability);
		}else {
			list = vulnerabilityMapper.selectVulnerabilityList(vulnerability);
		}

		map.put("page", vulnerability.getCurPage());
		map.put("total", vulnerability.getTotBlockSize());
		map.put("records", records);
		map.put("rows", list);
		return map;
	}
	
	@Override
	@Cacheable(value="autocompleteVulnerabilityCache", key="{#root.methodName}")
	public HashMap<String, Object> getVulnerabilityAutoComplete() {
		
		HashMap<String, Object> map = new HashMap<String, Object>();
		
		List<String> nameList = vulnerabilityMapper.selectVulnerabilityOSSNameAutoComplete();
		List<String> cveIdList = vulnerabilityMapper.selectVulnerabilityCveIdAutoComplete();
		
		map.put("nameList", nameList);
		map.put("cveIdList", cveIdList);

		return map;
	}

	@Override
	public List<String> getVulnerabilityVersionAutoComplete(String name) {

		List<String> versionList = vulnerabilityMapper.selectVulnerabilityOSSVersionAutoComplete(name);
		
		return versionList;
	}
	
	@Override
	public Map<String, Object> getVulnListByOssName(OssMaster bean) {
		Map<String, Object> result = new HashMap<String, Object>();
		
		if("N/A".equals(bean.getOssVersion())) {
			bean.setOssVersion("");
		}
		
		List<Vulnerability> list = null;
		String[] nicknameList = null;
		int records = 0;
		
		try {
			nicknameList = ossService.getOssNickNameListByOssName(bean.getOssName());
			
			bean.setOssNicknames(nicknameList);
			
			records = vulnerabilityMapper.getVulnListByOssNameCnt(bean);
			
			bean.setTotListSize(records);
			
			list = vulnerabilityMapper.getVulnListByOssName(bean);
		} catch (Exception e) {
			log.error(e.getMessage());
		}
		
		list = checkVulnData(list, nicknameList);
		
		result.put("page", bean.getCurPage());
		result.put("total", bean.getTotBlockSize());
		result.put("records", records); // total cnt를 cveCnt에 담아두고 관리함.
		result.put("rows", list);
		
		return result;
	}
	
	public List<Vulnerability> checkVulnData(List<Vulnerability> list, String[] nicknameList){
		List<Vulnerability> result = new ArrayList<Vulnerability>();
				
		for(Vulnerability bean : list) {
			bean.setOssNameAllSearchFlag(CoConstDef.FLAG_YES);
			if(nicknameList != null) {
				bean.setOssNicknames(nicknameList);
			}
			int vulnCnt = vulnerabilityMapper.checkVulnDataCnt(bean);
			if(vulnCnt > 0) {
				result.add(bean);
			}
		}
		
		return result;
	}
	

	public void doSyncOSSNvdInfo() {

		vulnerabilityMapper.updateOssRecheckVulnFlag();

		List<String> notUsedOssList = new ArrayList<>();
		Map<String, OssMaster> reCalcOssInfoMap = new HashMap<>();
		List<String> _prjMailList = new ArrayList<>();
		List<String> _reCalcPrjMailList = new ArrayList<>();
		List<String> _removeReCalcPrjMailList = new ArrayList<>();
		Map<String, OssMaster> ossInfoMap = CoCodeManager.OSS_INFO_BY_ID;
		List<String> checkedOssList = new ArrayList<>();
		boolean hasNvdData = vulnerabilityMapper.selectNvdTotalCount() > 0;
		for(String ossKey : ossInfoMap.keySet()) {
			OssMaster ossBean = ossInfoMap.get(ossKey);
			if(checkedOssList.contains(ossBean.getOssId())) {
				continue;
			}
			checkedOssList.add(ossBean.getOssId());
			ossBean.setOssVersion(avoidNull(ossBean.getOssVersion()));
			Map<String, Object> nvdInfo = vulnerabilityMapper.selectNvdInfo(ossBean);
			boolean reCheckNVDInfo = false;
			if(nvdInfo != null && !nvdInfo.isEmpty()) {
				BigDecimal bdScore = new BigDecimal(String.valueOf(nvdInfo.get("CVSS_SCORE")));
				BigDecimal bdOrgMasterScore = new BigDecimal(CommonFunction.avoidNull(ossBean.getCvssScore(), "0"));
				String cveId = String.valueOf(nvdInfo.get("CVE_ID"));
				// 현재 등록되어 있는 score와 cve_id가 일치하지 않으면 업데이트
				if( !bdScore.equals(bdOrgMasterScore) || !cveId.equals(ossBean.getCveId())) {
					ossBean.setCvssScoreTo(String.valueOf(nvdInfo.get("CVSS_SCORE")));
					ossBean.setCveIdTo(String.valueOf(nvdInfo.get("CVE_ID")));
					vulnerabilityMapper.insertNvdOssHis(ossBean);
					
					OssMaster newNVD = new OssMaster();
					newNVD.setOssId(ossBean.getOssId());
					newNVD.setCvssScore(ossBean.getCvssScoreTo());
					newNVD.setCveId(ossBean.getCveIdTo());
					vulnerabilityMapper.updateOssVulnInfoNew(newNVD);
				}

				// score가 7.0 이상인 경우만 메일을 발송
				// 처음으로 9.0 이상 Score가 등록된 경우 (기존 Score가 9.0 미만이고 NVD update score가 9.0 이상인 경우)
				// vulnerability mail > base score changed from 9.0 to 8.0
				if(bdScore.compareTo(new BigDecimal("8.0")) > -1 && bdOrgMasterScore.compareTo(new BigDecimal("8.0")) < 0) {
					String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
					ossBean.setOssNames(nickNameList);
					List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
					if(_prjList != null && !_prjList.isEmpty()) {
						_prjMailList.addAll(_prjList);
					}
					notUsedOssList.add(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion());
				}
				
				// NVD Score가 9.0 미만이면서 기존 Score가 9.0 이상인 경우, Score가 변경되었음을 메일로 통지
				// vulnerability mail > base score changed from 9.0 to 8.0
				if(bdScore.compareTo(new BigDecimal("8.0")) < 0 && bdOrgMasterScore.compareTo(new BigDecimal("8.0")) > -1) {
					String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
					ossBean.setOssNames(nickNameList);
					List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
					if(_prjList != null && !_prjList.isEmpty()) {
						_reCalcPrjMailList.addAll(_prjList);
					}
					reCalcOssInfoMap.put(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion(), ossBean);
				}
			}

			// 일치하는 결과가 없고, OSS VERSION이 설정되어 있지 않은 경우 해당 OSS의 MAX SCORE를 등록한다.
			else if(isEmpty(ossBean.getOssVersion())) {
				Map<String, Object> nvdInfo2 = vulnerabilityMapper.selectNvdInfoWithOutVer(ossBean);
				if(nvdInfo2 != null && !nvdInfo2.isEmpty()) {

					BigDecimal bdScore = new BigDecimal(String.valueOf(nvdInfo2.get("CVSS_SCORE")));
					BigDecimal bdOrgMasterScore = new BigDecimal(CommonFunction.avoidNull(ossBean.getCvssScore(), "0"));
					String cveId = String.valueOf(nvdInfo2.get("CVE_ID"));
					// 현재 등록되어 있는 score와 cve_id가 일치하지 않으면 업데이트
					if( !bdScore.equals(bdOrgMasterScore) || !cveId.equals(ossBean.getCveId())) {
						scheduler_log.info("Vulnerability updateOssVulnInfo OSS ID : " + ossBean.getOssId());
						ossBean.setCvssScoreTo(String.valueOf(nvdInfo2.get("CVSS_SCORE")));
						ossBean.setCveIdTo(String.valueOf(nvdInfo2.get("CVE_ID")));
						vulnerabilityMapper.insertNvdOssHis(ossBean);
						
						OssMaster newNVD = new OssMaster();
						newNVD.setOssId(ossBean.getOssId());
						newNVD.setCvssScore(ossBean.getCvssScoreTo());
						newNVD.setCveId(ossBean.getCveIdTo());
						vulnerabilityMapper.updateOssVulnInfoNew(newNVD);

						// score가 7.0 이상인 경우만 메일을 발송
						// 처음으로 9.0 이상 Score가 등록된 경우 (기존 Score가 9.0 미만이고 NVD update score가 9.0 이상인 경우)
						// vulnerability mail > base score changed from 9.0 to 8.0
						if(bdScore.compareTo(new BigDecimal("8.0")) > -1 && bdOrgMasterScore.compareTo(new BigDecimal("8.0")) < 0) {
							String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
							ossBean.setOssNames(nickNameList);
							List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
							if(_prjList != null && !_prjList.isEmpty()) {
								_prjMailList.addAll(_prjList);
							}
							notUsedOssList.add(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion());
						}
						
						// NVD Score가 9.0 미만이면서 기존 Score가 9.0 이상인 경우, Score가 변경되었음을 메일로 통지
						// vulnerability mail > base score changed from 9.0 to 8.0
						if(bdScore.compareTo(new BigDecimal("8.0")) < 0 && bdOrgMasterScore.compareTo(new BigDecimal("8.0")) > -1) {
							String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
							ossBean.setOssNames(nickNameList);
							List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
							if(_prjList != null && !_prjList.isEmpty()) {
								_reCalcPrjMailList.addAll(_prjList);
							}
							reCalcOssInfoMap.put(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion(), ossBean);
						}
					}
				} else {
					// NVD 삭제 여부를 체크한다.
					reCheckNVDInfo = true;
				}
			}
			else {
				// NVD 삭제 여부를 체크한다.
				reCheckNVDInfo = true;
			}

			// NVD 정보는 없지만 oss list에 nvd 정보가 이미 설정되어 있는 경우
			// NVD 사이트에서 Excluding 되었을 가능성이 높다 (삭제됨)
			if(reCheckNVDInfo) {
				// 혹시 BATCH에서 오류가 발생하여 NVD_DATA_SCORE_V3 테이블에 DATA 가 등록되지 않은 경우 
				// 모든 NVD DATA가 삭제되는 것을 방지하기 위해서 건수가 0건이상인지 확인한다.
				if(hasNvdData && !isEmpty(ossBean.getCveId())) {
					scheduler_log.info("Vulnerability deleteOssVulnInfo OSS ID : " + ossBean.getOssId());
					// oss list에서 NVD 정보를 삭제한다.
					ossBean.setCvssScoreTo("0");
					ossBean.setCveIdTo("");
					vulnerabilityMapper.insertNvdOssHis(ossBean);
					vulnerabilityMapper.deleteOssVulnInfo(ossBean.getOssId());
					
					BigDecimal bdOrgMasterScore = new BigDecimal(String.valueOf(ossBean.getCvssScore()));
					
					// vulnerability mail > base score changed from 9.0 to 8.0
					if(bdOrgMasterScore.compareTo(new BigDecimal("8.0")) > -1) {
						String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
						ossBean.setOssNames(nickNameList);
						List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
						if(_prjList != null && !_prjList.isEmpty()) {
							_removeReCalcPrjMailList.addAll(_prjList);
						}
						
						reCalcOssInfoMap.put(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion(), ossBean);
					}
				}
			}
		}
		
		CoCodeManager.getInstance().refreshOssInfo();
		
		if(_prjMailList != null && !_prjMailList.isEmpty()) {
			List<String> prjMailList = new ArrayList<String>(new HashSet<String>(_prjMailList));
			scheduler_log.info("Vulnerability prj COUNT : " + prjMailList.size());
			for(String prjId : prjMailList) {
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT);
				mailBean.setParamPrjId(prjId);
				CoMailManager.getInstance().sendMail(mailBean);
			}
			
		}
		

		if(_reCalcPrjMailList != null && !_reCalcPrjMailList.isEmpty()) {
			List<String> prjMailList = new ArrayList<String>(new HashSet<String>(_reCalcPrjMailList));
			scheduler_log.info("Vulnerability risk recalculated prj COUNT : " + _reCalcPrjMailList.size());
			for(String prjId : prjMailList) {
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT_RECALCULATED);
				mailBean.setParamPrjId(prjId);
				mailBean.setParamOssInfoMap(reCalcOssInfoMap);
				CoMailManager.getInstance().sendMail(mailBean);
			}
			
		}
		
		if(_removeReCalcPrjMailList != null && !_removeReCalcPrjMailList.isEmpty()) {
			List<String> prjMailList = new ArrayList<String>(new HashSet<String>(_removeReCalcPrjMailList));
			scheduler_log.info("Vulnerability risk remove > recalculated prj COUNT : " + _removeReCalcPrjMailList.size());
			for(String prjId : prjMailList) {
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT_REMOVE_RECALCULATED);
				mailBean.setParamPrjId(prjId);
				mailBean.setParamOssInfoMap(reCalcOssInfoMap);
				CoMailManager.getInstance().sendMail(mailBean);
			}
			
		}
		
		if(!notUsedOssList.isEmpty()) {
			try {
				scheduler_log.info("Vulnerability notUsedOssList COUNT : " + notUsedOssList.size());
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_OSS);
				mailBean.setParamOssKey(notUsedOssList);
				CoMailManager.getInstance().sendMail(mailBean);
			} catch (Exception e) {
				scheduler_log.error(e.getMessage(), e);
			}
		}
		
		if(reCalcOssInfoMap.keySet().size() > 0) {
			try {
				scheduler_log.info("Vulnerability reCalculated All COUNT : " + reCalcOssInfoMap.keySet().size());
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT_RECALCULATED_ALL);
				ArrayList<String> keyList = new ArrayList<String>(reCalcOssInfoMap.keySet());
				mailBean.setParamOssKey(keyList);
				CoMailManager.getInstance().sendMail(mailBean);
			} catch (Exception e) {
				scheduler_log.error(e.getMessage(), e);
			}
		}
	}

	@Override
	public Map<String, Object> getCveInfo(String cveId) {
		return vulnerabilityMapper.getCveInfo(cveId);
	}
}
